'''
DFS 탐색문제

- 11개의 점수(10점 -> 0점)을 역순으로 순서대로 확인하면서 각 칸에 쏘기/쏘지 않기 - 경우의 수를 탐색

- 문제 조건
1. 가장 큰 점수차로 이기는 경우를 반환할 것
2. 같은 점수차라면 작은 칸(점수)을 많이 쏜 경우를 우선으로 할 것 
3. 만약 어떻게 해도 이길 수 없으면 [-1] 반환

- 아이디어
1. 해당 칸을 라이언이 가져오려면 어피치보다 하나만 더 쏴도 해당 칸을 가져올 수 있음
    -> 라이언이 해당 칸을 어피치보다 1발만 더 쏴도 가져올 수 있음 
        - 동점이랑 적게 쏜 경우는 어피치가 해당 칸을 가져감(문제 조건)
2. 문제 조건2를 만족하기 위해 칸을 가져오기 위해 쏘고 남은 화살은 모두 0점에 몰빵
    -> 작은 칸을 가장 많이 쏜 경우라고 할 수 있음 - 총합 n의 조건도 만족    
3. 모든 쏘기/안쏘기 경우를 탐색하여 리스트를 만들면서 조건 1,2를 만족하는 상황이 나오면 해당 리스트로 갱신신
'''


def solution(n, info):
    ryan = [0] * 11     # 라이언 빈 화살 리스트
    best_score = 0  ### 최고 점수차 
    best_ryan = [-1]    ### 최고 점수차일 때 라이언의 화살 리스트 : 문제에서 이길 수 없는 경우 -1이므로 디폴트 값은 -1

    # 인덱스, 남은 화살, 현재 상태
    stack = [(0, n, [0]*11)]

    while stack:    # 스택 값이 빌 때까지 반복
        idx, left, now = stack.pop()

        # 11칸 다 하면 점수 계산
        if idx == 11:
            # 만약에 화살이 남으면 남은건 다 0에다가 쏘기(문제에서 가장 낮은 점수를 더 많이 맞힌 경우가 정답)
            if left > 0:    
                now[10] += left     # now[10] : 0점
            
            # 라이언 점수, 어피치 점수 초기화
            r_score, a_score = 0, 0
            
            for i in range(11):
                ## i번째 원의 점수
                score = 10 - i
                # 둘 다 쏜 횟수가 0인 경우에는 아무도 해당 원의 점수를 안 가져가니까 패스
                if now[i] == 0 and info[i] == 0:
                    continue
                # 라이언이 쏜 값이 어피치 값보다 크면 해당 원의 점수는 라이언이 가져감
                if now[i] > info[i]:
                    r_score += score
                # 어피치가 더 많이 쏘거나 동점이면 해당 원의 점수는 어피치가 가져감
                else:
                    a_score += score
            
            ## 라이언과 어피치 총 점수의 차
            diff = r_score - a_score
            
            # 점수차가 0보다 작으면 이길 수 없음 -> 초기 값인 -1 반환
            ## 점수차가 0보다 크면 이길 수 있음
            if diff > 0:
                ## 해당 점수차와 배열로 갱신
                # 1. 점수차가 현재의 최고점수차보다 크거나(문제에서 점수차가 가장 큰 경우가 정답)
                # 2. 점수차가 현재 점수차랑 같다면 더 낮은 점수를 많이 맞힌 리스트가 정답임 - 뒤집어서 비교(점수가 역순이니까)
                if diff > best_score or (diff == best_score and now[::-1] > best_ryan[::-1]):
                    best_score = diff
                    best_ryan = now[:]

            # 초기화
            if left > 0:
                now[10] -= left
            continue

        # 라이언이 이길 수 있음
        need = info[idx] + 1 #라이언이 이기기 위해 해당 점수에 쏴야하는 화살 수
        if left >= need:
            ryan_shoot = now[:]   # 참조를 위한 복사본
            ryan_shoot[idx] = need
            stack.append((idx + 1, left - need, ryan_shoot))

        # 라이언이 이길 수 없는 경우 포기 : -1 반환
        ryan_shoot = now[:]
        stack.append((idx + 1, left, ryan_shoot))

    # 최고 점수차일 때 라이언 화살리스트 반환 / 어떻게 해도 이길 수 없으면 -1 반환
    if best_ryan != [-1]:
        return best_ryan
    else:
        return [-1]
